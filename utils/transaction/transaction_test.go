package transaction

import (
	"context"
	"testing"
	"time"

	"github.com/aperturerobotics/inca"
	"github.com/aperturerobotics/pbobject"
	"github.com/aperturerobotics/timestamp"
	"github.com/libp2p/go-libp2p-crypto"
)

var testPrivKeyDat = []byte{
	0x8, 0x1, 0x12, 0x60, 0x97, 0x4, 0x8b, 0x9b, 0x6, 0xf2,
	0x50, 0x9c, 0xd4, 0x4, 0x74, 0xe7, 0x2e, 0x49, 0x85, 0xd,
	0xb8, 0xf0, 0x21, 0x53, 0x25, 0x7f, 0x6b, 0xa0, 0x29, 0x44,
	0x72, 0x38, 0xd7, 0x98, 0x13, 0xce, 0x7c, 0x9f, 0x1c, 0xe7,
	0xa2, 0x7e, 0x88, 0x78, 0x43, 0x19, 0x5a, 0x67, 0x4e, 0x2c,
	0x98, 0x4a, 0x66, 0x12, 0x84, 0xed, 0xd7, 0x8, 0x70, 0x42,
	0x7, 0x14, 0x52, 0x6c, 0x2f, 0x14, 0x3e, 0x93, 0x7c, 0x9f,
	0x1c, 0xe7, 0xa2, 0x7e, 0x88, 0x78, 0x43, 0x19, 0x5a, 0x67,
	0x4e, 0x2c, 0x98, 0x4a, 0x66, 0x12, 0x84, 0xed, 0xd7, 0x8,
	0x70, 0x42, 0x7, 0x14, 0x52, 0x6c, 0x2f, 0x14, 0x3e, 0x93,
}

var testPubKeyDat = []byte{
	0x8, 0x1, 0x12, 0x20, 0x7c, 0x9f, 0x1c, 0xe7, 0xa2, 0x7e,
	0x88, 0x78, 0x43, 0x19, 0x5a, 0x67, 0x4e, 0x2c, 0x98, 0x4a,
	0x66, 0x12, 0x84, 0xed, 0xd7, 0x8, 0x70, 0x42, 0x7, 0x14,
	0x52, 0x6c, 0x2f, 0x14, 0x3e, 0x93,
}

func parseTestPubKey(t *testing.T) crypto.PubKey {
	pk, err := crypto.UnmarshalPublicKey(testPubKeyDat)
	if err != nil {
		t.Fatal(err.Error())
	}
	return pk
}

func parseTestPriKey(t *testing.T) crypto.PrivKey {
	pk, err := crypto.UnmarshalPrivateKey(testPrivKeyDat)
	if err != nil {
		t.Fatal(err.Error())
	}
	return pk
}

var testTxTimestamp = timestamp.ToTimestamp(time.Unix(1000, 0))

// TestFromNodeMessage tests building a tx from a node message.
func TestFromNodeMessage(t *testing.T) {
	ctx := context.Background()
	messageTs := testTxTimestamp
	nodeMessage := &inca.NodeMessage{
		Timestamp:      &messageTs,
		MessageType:    inca.NodeMessageType_NodeMessageType_APP,
		AppMessageType: TransactionAppMessageID,
	}
	priKey := parseTestPriKey(t)
	encConf := pbobject.EncryptionConfig{
		Context:    ctx,
		SignerKeys: []crypto.PrivKey{priKey},
	}

	w, _, err := pbobject.NewObjectWrapper(nodeMessage, encConf)
	if err != nil {
		t.Fatal(err.Error())
	}

	tx, err := FromNodeMessage(w, nodeMessage, priKey.GetPublic())
	if err != nil {
		t.Fatal(err.Error())
	}
	_ = tx
}

// TestComputeTxID tests computing a transaction ID.
func TestComputeTxID(t *testing.T) {
	ts := testTxTimestamp
	pubKey := parseTestPubKey(t)
	txID, err := ComputeTxID(&ts, pubKey)
	if err != nil {
		t.Fatal(err.Error())
	}

	t.Logf("tx id: %s", txID)
	expectedID := "3ff1e0950811b196f4355708cee12d599f6c8a0d"
	if txID != expectedID {
		t.Fatalf("expected tx id: %v", expectedID)
	}
}
